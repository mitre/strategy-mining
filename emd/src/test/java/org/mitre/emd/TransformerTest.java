package org.mitre.emd;

import ec.gp.GPNode;
import org.junit.Test;
import org.mitre.emd.rules.Factor;
import org.objectweb.asm.*;
import org.objectweb.asm.commons.*;
//import org.objectweb.asm.commons.RemappingClassAdapter;
//import org.objectweb.asm.commons.RemappingMethodAdapter;
import org.objectweb.asm.tree.*;

import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.*;

import static org.objectweb.asm.Opcodes.*;


public class TransformerTest {
    @Test
    public void testTransformer() throws Exception {
        Transformer transformer = new Transformer();
        String className = "NewFactor";
        byte[] bytes = FactorAsm.dump(className);
        transformer.writeClass(bytes,className);
    }

//    @Test
    public void testRemoveMethod() throws IOException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, ClassNotFoundException {
        String classToRename = "org.mitre.emd.rules.Factor";  // This is the class you want to rename
        String classToWrite = "FactorMinus";  // Name of the new class we're writing
        String classToRead = "org.mitre.emd.models.students.StudentFoo";  // This is the class we read a method from
        String methodToRead = "method2";  // This is the method we want to read in classToRead

        String slashName = classToRename.replace('.', '/');

        ClassReader reader = new ClassReader(classToRename);
        ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);

        // Rename the class to classToWrite
        Remapper remapper = new Remapper() {
            @Override
            public String map(String typeName) {
                if (typeName.equals(slashName)) {
                    return "org/mitre/emd/rules/" + classToWrite;
                }
                return super.map(typeName);
            }

        };
//        RemappingClassAdapter adapter = new RemappingClassAdapter(writer, remapper);

        MyRemappingClassAdapter adapter = new MyRemappingClassAdapter(writer, remapper);

        reader.accept(adapter, ClassReader.EXPAND_FRAMES);
        writer.visitEnd();

        Transformer transformer = new Transformer();
        byte[] bytes = writer.toByteArray();
        transformer.writeClass(bytes,classToWrite);

        // Load the class from the byte array directly, this doesn't seem to work
//        Class<?> myClass = loadClass(bytes);
//        Constructor<GPNode> myConstructor = (Constructor<GPNode>) myClass.getConstructor();
//        GPNode myFactor = myConstructor.newInstance();
//        System.out.println(myFactor.toString());

        // Load the class from the class file
        Class<?> newClass = this.getClass().getClassLoader().loadClass("org.mitre.emd.rules." + classToWrite);
        Constructor<GPNode> constructor = (Constructor<GPNode>) newClass.getConstructor();
        GPNode factor = constructor.newInstance();
        System.out.println(factor.toString());
    }


    /**
     * TODO This results in a CME.
     */
    public void testRemoveThenReplaceMethod() throws IOException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, ClassNotFoundException {
        String classToRename = "org.mitre.emd.rules.Factor";  // This is the class you want to rename
        String classToWrite = "FactorMinus";  // Name of the new class we're writing
        String classToRead = "org.mitre.emd.models.students.StudentFoo";  // This is the class we read a method from
        String methodToRead = "method2";  // This is the method we want to read in classToRead

        String slashName = classToRename.replace('.', '/');

        ClassReader reader = new ClassReader(classToRename);
        ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_FRAMES);

        // Rename the class to classToWrite
        Remapper remapper = new Remapper() {
            @Override
            public String map(String typeName) {
                if (typeName.equals(slashName)) {
                    return "org/mitre/emd/rules/" + classToWrite;
                }
                return super.map(typeName);
            }

        };
        ClassRemapper adapter = new ClassRemapper(writer, remapper);

//        MyNewRemappingClassAdapter adapter = new MyNewRemappingClassAdapter(writer, remapper);

        reader.accept(adapter, ClassReader.EXPAND_FRAMES);
        writer.visitEnd();

        byte[] renamedBytes = writer.toByteArray();  // renamedBytes is the representation of classToRename renamed as classToWrite

        // For debugging, this prints what the renamed class looks like
        ClassPrinter cp = new ClassPrinter();
        ClassReader cr = new ClassReader(renamedBytes);
        cr.accept(cp, 0);  // events generated by cr are consumed by cp

//        ClassReader myReader = new ClassReader(bytes);
//        writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);
//
//        ClassNode cn = new ClassNode();
//        myReader.accept(cn, 0);
//        ClassVisitor studentCv = new ClassVisitor(ASM7, cn) { };
//        MergeAdapter ma = new MergeAdapter(studentCv, cn);
//        ClassReader methodInClassReader = new ClassReader(classToRead);
//        ClassVisitor classVisitor = new ClassVisitor(ASM9, ma) { };
//
//        MethodReplacer methodReplacer = new MethodReplacer(classVisitor, methodToRead, classToWrite);
//        methodInClassReader.accept(methodReplacer,ClassReader.EXPAND_FRAMES);
//
//        myReader.accept(adapter, ClassReader.EXPAND_FRAMES);
//        writer.visitEnd();

//        writer = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
//
//        ClassReader methodInClassReader = new ClassReader(classToRead);
//        ClassVisitor classVisitor = new ClassVisitor(ASM9, writer) { };
//
//        MethodReplacer methodReplacer = new MethodReplacer(classVisitor, methodToRead, classToWrite);
//        methodInClassReader.accept(methodReplacer,ClassReader.EXPAND_FRAMES);  // events generated by methodInClassReader are consumed by methodReplacer

//        reader.accept(adapter, ClassReader.EXPAND_FRAMES);
//        writer.visitEnd();

        // Read in the renamed class
//        ClassReader renamedClassReader = new ClassReader(bytes);
//        ClassVisitor classVisitor = new MyClassAdapter(writer) { };
//
//        MethodReplacer methodReplacer = new MethodReplacer(classVisitor, methodToRead, classToWrite);
//        renamedClassReader.accept(methodReplacer,ClassReader.EXPAND_FRAMES);  // events generated by renamedClassReader are consumed by methodReplacer

//        reader.accept(adapter, ClassReader.EXPAND_FRAMES);
//        writer.visitEnd();

//        byte[] methodOnlyBytes = writer.toByteArray();

        ClassReader methodInClassReader = new ClassReader(classToRead);
        ClassNode cn = new ClassNode();
        methodInClassReader.accept(cn, ClassReader.EXPAND_FRAMES);  // events generated by methodInClassReader are consumed by cn

        ClassReader renamedReader = new ClassReader(renamedBytes);
        writer = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
        ClassVisitor visitor = new MergeAdapter(writer, cn);
        renamedReader.accept(visitor,ClassReader.EXPAND_FRAMES);  // events generated by renamedReader are consumed by visitor


//        ClassReader renamedReader = new ClassReader(renamedBytes);
//        ClassNode cn = new ClassNode();
////        renamedReader.accept(cn, 0);

//        writer = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
//        ClassVisitor classVisitor = new ClassVisitor(ASM9, writer) { };  // classVisitor forwards all events to writer
//        MergeAdapter ma = new MergeAdapter(classVisitor, cn);
//
//        renamedReader.accept(ma, 0);  // events generated by renamedReader are consumed by ma



        Transformer transformer = new Transformer();
        transformer.writeClass(writer.toByteArray(),classToWrite);

//        Class<?> newClass = Class.forName("org.mitre.emd.rules." + classToWrite);
        // Load the class from the class file
        Class<?> newClass = this.getClass().getClassLoader().loadClass("org.mitre.emd.rules." + classToWrite);
        Constructor<GPNode> constructor = (Constructor<GPNode>) newClass.getConstructor();
        GPNode factor = constructor.newInstance();
        System.out.println(factor.toString());


//        transformer.writeClass(bytes,classToWrite);

        // Load the class from the byte array directly, this doesn't seem to work
//        Class<?> myClass = loadClass(bytes);
//        Constructor<GPNode> myConstructor = (Constructor<GPNode>) myClass.getConstructor();
//        GPNode myFactor = myConstructor.newInstance();
//        System.out.println(myFactor.toString());

        // Load the class from the class file
//        Class<?> newClass = this.getClass().getClassLoader().loadClass("org.mitre.emd.rules." + classToWrite);
//        Constructor<GPNode> constructor = (Constructor<GPNode>) newClass.getConstructor();
//        GPNode factor = constructor.newInstance();
//        System.out.println(factor.toString());
    }

    public class MyClassAdapter extends ClassNode {
        public MyClassAdapter(ClassVisitor cv) {
            super(ASM9);
            this.cv = cv;
        }
        @Override public void visitEnd() {
            // put your transformation code here
            accept(cv);
        }
    }


//    @Test
    /**
     * This works
     */
    public void testRemapClass() throws IOException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, ClassNotFoundException {
        String classToRename = "org.mitre.emd.rules.Factor";  // This is the class you want to rename
        String classToWrite = "FactorMinus";  // Name of the new class we're writing
        String classToRead = "org.mitre.emd.models.students.StudentFoo";  // This is the class we read a method from
        String methodToRead = "method2";  // This is the method we want to read in classToRead

        String slashName = classToRename.replace('.', '/');

        ClassReader reader = new ClassReader(classToRename);
        ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_FRAMES);

        // Rename the class to classToWrite
        Remapper remapper = new Remapper() {
            @Override
            public String map(String typeName) {
                if (typeName.equals(slashName)) {
                    return "org/mitre/emd/rules/" + classToWrite;
                }
                return super.map(typeName);
            }

        };
//        RemappingClassAdapter adapter = new RemappingClassAdapter(writer, remapper);

        MyNewRemappingClassAdapter adapter = new MyNewRemappingClassAdapter(writer, remapper);

        reader.accept(adapter, ClassReader.EXPAND_FRAMES);
        writer.visitEnd();

        byte[] bytes = writer.toByteArray();

        ClassPrinter cp = new ClassPrinter();
        ClassReader cr = new ClassReader(bytes);
        cr.accept(cp, 0);

        Transformer transformer = new Transformer();
        transformer.writeClass(bytes,classToWrite);

        // Load the class from the class file
        Class<?> newClass = this.getClass().getClassLoader().loadClass("org.mitre.emd.rules." + classToWrite);
        Constructor<GPNode> constructor = (Constructor<GPNode>) newClass.getConstructor();
        GPNode factor = constructor.newInstance();
        System.out.println(factor.toString());
    }

//    @Test
    public void renameAndReplaceClass() throws IOException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, ClassNotFoundException {
        String classToRename = "org.mitre.emd.rules.Factor";  // This is the class you want to rename
        String classToWrite = "StudentFactor";  // Name of the new class we're writing
        String classToRead = "org.mitre.emd.models.students.StudentFoo";  // This is the class we read a method from
        String methodToRead = "method2";  // This is the method we want to read in classToRead

        String renameSlashName = classToRename.replace('.', '/');
        String readSlashName = classToRead.replace('.', '/');

        ClassReader reader = new ClassReader(classToRename);
        ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_FRAMES);

        // Rename the class to classToWrite
        Remapper remapper = new Remapper() {
            /**
             * Rename the class
             */
            @Override
            public String map(String typeName) {
                if (typeName.equals(renameSlashName)) {
                    return "org/mitre/emd/rules/" + classToWrite;
                }
                return super.map(typeName);
            }

            /**
             * Rename eval2 to eval
             * @param owner
             * @param newName
             * @param desc
             * @return
             */
            @Override
            public String mapMethodName(String owner, String newName, String desc){
                if(owner.equals(readSlashName)){
//                    System.out.println("Owner " + owner + " newName " + newName + " desc " + desc);
                    return super.mapMethodName(owner,"eval",desc);
                }
                return super.mapMethodName(owner,newName,desc);
            }

        };

        MyRemappingClassAdapter adapter = new MyRemappingClassAdapter(writer, remapper);

        ClassReader methodInClassReader = new ClassReader(classToRead);
        ClassVisitor classVisitor = new ClassVisitor(ASM9, adapter) { };

        MethodReplacer methodReplacer = new MethodReplacer(classVisitor, methodToRead, classToWrite);
        methodInClassReader.accept(methodReplacer,ClassReader.EXPAND_FRAMES);

        reader.accept(adapter, ClassReader.EXPAND_FRAMES);
        writer.visitEnd();

        Transformer transformer = new Transformer();
        byte[] bytes = writer.toByteArray();
        transformer.writeClass(bytes,classToWrite);

//        Class<?> newClass = Class.forName("org.mitre.emd.rules." + classToWrite);
        Class<?> newClass = this.getClass().getClassLoader().loadClass("org.mitre.emd.rules." + classToWrite);
        Constructor<Factor> constructor = (Constructor<Factor>) newClass.getConstructor();
        Factor factor = constructor.newInstance();
        System.out.println(factor.toString());
    }

//    @Test
    public void testNewClass() throws ClassNotFoundException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException {
        Class<?> newClass = this.getClass().getClassLoader().loadClass("org.mitre.emd.rules.FactorMinus");
        Constructor<GPNode> constructor = (Constructor<GPNode>) newClass.getConstructor();
        GPNode factor = constructor.newInstance();
        System.out.println(factor.toString());
    }

//    @Test
    public void testMethodReplacer() throws IOException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, ClassNotFoundException {
        // MethodReplacer is adapted from the Kuleshov paper

        String classToClone = "org.mitre.emd.Factor";  // This is the class you want to clone and put the method from the other class into.
        String classToRead = "org.mitre.emd.models.students.StudentFoo";  // This is the class we read a method from
        String methodToRead = "method2";  // This is the method we want to read in classToRead
        String classToWrite = "NewFactor";  // Name of the new class we're writing

        ClassWriter cw = new ClassWriter(0);
        ClassReader cr = new ClassReader(classToClone);
        ClassVisitor cv = new ClassVisitor(ASM9, cw) { };

        ClassReader otherCr = new ClassReader(classToRead);
        ClassVisitor studentCv = new ClassVisitor(ASM9, cv) { };
        MethodReplacer mr = new MethodReplacer(studentCv, methodToRead, classToWrite);
        otherCr.accept(mr,0);

        cr.accept(cv,0);

        Transformer transformer = new Transformer();
        byte[] bytes = cw.toByteArray();
        transformer.writeClass(bytes,classToWrite);

//        Class<?> newFactor = this.getClass().getClassLoader().loadClass("org.mitre.emd.rules.Factor");
//        Method eval = newFactor.getClass().getMethod("eval");
//        eval.invoke(newFactor);

        Class factor = loadClass(bytes, "org.mitre.emd.NewFactor");
        Object instance = new Object();
        factor.getMethod("toString").invoke(instance);
//        System.out.println(((Factor) factor).description);
//        Method eval = factor.getClass().getMethod("eval");
//        eval.invoke(factor);
    }


    public class MyRemappingClassAdapter extends ClassRemapper { // RemappingClassAdapter{

        public MyRemappingClassAdapter(ClassVisitor cv, Remapper remapper) {
            super(cv, remapper);
        }

        @Override
        public MethodVisitor visitMethod(int access, String name, String desc,
                                         String signature, String[] exceptions) {
            if(name.equals("eval")){
                return null;
            } else {
                return super.visitMethod(access, name, desc, signature, exceptions);
            }
        }
    }

    public class MyNewRemappingClassAdapter extends ClassRemapper{

        public MyNewRemappingClassAdapter(ClassVisitor cv, Remapper remapper) {
            super(cv, remapper);
        }

        @Override
        public MethodVisitor visitMethod(int access, String name, String desc,
                                         String signature, String[] exceptions) {
            return super.visitMethod(access, name, desc, signature, exceptions);
        }
    }

    public class MethodRemovingClassVisitor extends ClassVisitor{

        public MethodRemovingClassVisitor(int api, ClassVisitor classVisitor) {
            super(api, classVisitor);
        }

        /**
         * If a method's name matches methodToRead it's body is copied to the new class otherwise it's ignored.
         * @param access
         * @param name
         * @param desc
         * @param signature
         * @param exceptions
         * @return
         */
        public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions){
            System.out.println(" " + name + desc);


            if(name.equals("eval")){
                System.out.println("found!");
                return null;
            }
            MethodVisitor mv = cv.visitMethod(access, name, desc, signature, exceptions);
            return mv;
        }
    }

    public class MethodReplacer extends ClassVisitor {
        private String mname;
        private String mdesc;
        private String cname;
        public MethodReplacer(ClassVisitor cv,
                              String mname, String cname) {
            super(ASM9,cv);
            this.mname = mname;
            this.cname = cname;
            this.mdesc = mdesc;
        }
        public void visit(int version, int access,
                          String name, String signature,
                          String superName, String[] interfaces) {

            // TODO DEBUG
            if ((Opcodes.ACC_PUBLIC & access) > 0) {
                System.err.println("Class name: " + name);
                System.err.println("Class signature: " + signature);
                System.err.println("Class super name: " + superName);
//                System.err.println("return type: " + Type.getReturnType(desc));
//                System.err.println("argument types: " + Arrays.toString(Type.getArgumentTypes(desc)));
            }

            cv.visit(version, access, name, signature, superName, interfaces);
        }

        public MethodVisitor visitMethod(int access,
                                         String name, String desc,
                                         String signature, String[] exceptions) {
            String newName = name;
            if(name.equals(mname)) {
                // TODO remove eval in Factor so that this one can be named eval and match its signature
                newName = "eval";
                // make desc the same as eval desc
                desc = "(Lec/EvolutionState;ILec/gp/GPData;Lec/gp/ADFStack;Lec/gp/GPIndividual;Lec/Problem;)V";
//                generateNewBody(access, desc, signature, exceptions, name, newName);

//                // TODO DEBUG
//                if((Opcodes.ACC_PUBLIC & access)>0) {
//                    System.err.println("method name: " + name);
//                    System.err.println("signature: " + signature);
//                    System.err.println("desc: " + desc);
//                    System.err.println("return type: " + Type.getReturnType(desc));
//                    System.err.println("argument types: " + Arrays.toString(Type.getArgumentTypes(desc)));
//                }
//
                MethodVisitor mv = super.visitMethod(access, newName, desc, signature, exceptions);
//                mv.visitCode();
//                // call original method
//                mv.visitVarInsn(Opcodes.ALOAD, 0); // this
//                mv.visitMethodInsn(access, cname, newName, desc);
                if(mv != null){
                    mv.visitCode();
                    mv.visitMaxs(0,0);
                    mv.visitEnd();
                }

                return mv;
            }
            return null;  // We don't care about any other methods so return null

        }

        private void generateNewBody(int access, String desc, String signature, String[] exceptions,
                                     String name, String newName) {
            MethodVisitor mv = cv.visitMethod(access, name, desc, signature, exceptions);
            System.out.println("generate: name " + name);
            mv.visitCode();
            // call original metod
            mv.visitVarInsn(Opcodes.ALOAD, 0); // this
            mv.visitMethodInsn(access, cname, newName, desc);
            mv.visitEnd();
        }
    }


    /**
     * From ASM FAQ on how to get your bytecode class on the system classloader
     * @param b
     * @return
     */
    private Class loadClass(byte[] b) {
        // Override defineClass (as it is protected) and define the class.
        Class clazz = null;
        try {
            ClassLoader loader = ClassLoader.getSystemClassLoader();
            Class cls = Class.forName("java.lang.ClassLoader");
            java.lang.reflect.Method method =
                    cls.getDeclaredMethod(
                            "defineClass",
                            new Class[] { String.class, byte[].class, int.class, int.class });

            // Protected method invocation.
            method.setAccessible(true);
            try {
                Object[] args =
                        new Object[] { "FactorMinus", b, new Integer(0), new Integer(b.length)};
                clazz = (Class) method.invoke(loader, args);
            } finally {
                method.setAccessible(false);
            }
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
        return clazz;
    }

    public class MergeAdapter extends ClassVisitor {
        private ClassNode cn;
        private String cname;

        public MergeAdapter(ClassVisitor cv, ClassNode cn) {
            super(ASM7,cv);
            this.cn = cn;
        }

        public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
            super.visit(version, access, name, signature, superName, interfaces);
            this.cname = name;
        }

        public MethodVisitor visitMethod(int access,
                                         String name, String desc,
                                         String signature, String[] exceptions) {
            String newName = name;
//            MethodVisitor mv = super.visitMethod(access, newName, desc, signature, exceptions);
//            return mv;
            if(name.equals("<init>")){
                return null;
            } else {
                MethodVisitor mv = super.visitMethod(access, newName, desc, signature, exceptions);
                return mv;
            }
//            if(name.equals("method2")) {
//                // TODO remove eval in Factor so that this one can be named eval and match its signature
//                newName = "eval";
//                // make desc the same as eval desc
//                desc = "(Lec/EvolutionState;ILec/gp/GPData;Lec/gp/ADFStack;Lec/gp/GPIndividual;Lec/Problem;)V";
//                MethodVisitor mv = super.visitMethod(access, newName, desc, signature, exceptions);
//                if(mv != null){
//                    mv.visitCode();
//                    mv.visitMaxs(0,0);
//                    mv.visitEnd();
//                }
////                return new RemappingMethodAdapter(access, desc, mv,
////                        new SimpleRemapper(cn.name, cname));
//                return mv;
//            }
//            return null;  // We don't care about any other methods so return null

        }

//        public MethodVisitor visitMethod(int access, String name, String desc,
//                                         String signature, String[] exceptions) {
//
//            MethodVisitor mv = cv.visitMethod(access, name, desc, signature, exceptions);
//
//            if(name.equals("method2")){
//                return new RemappingMethodAdapter(access, desc, mv,
//                        new SimpleRemapper(cn.name, cname));
//            } else return null;
//        }

        public void visitEnd() {
            for (Iterator it = cn.fields.iterator(); it.hasNext(); ) {
                ((FieldNode) it.next()).accept(this);
            }
            for (Iterator it = cn.methods.iterator(); it.hasNext(); ) {
                MethodNode mn = (MethodNode) it.next();
                String[] exceptions = new String[mn.exceptions.size()];
                mn.exceptions.toArray(exceptions);
                MethodVisitor mv = cv.visitMethod(mn.access, mn.name, mn.desc, mn.signature, exceptions);
                mn.instructions.resetLabels();
                mn.accept(new MethodRemapper(mv, new SimpleRemapper(cname, cn.name)));
            }
            super.visitEnd();
        }
    }

    private Class loadClass(byte[] b, String className) {
        // Override defineClass (as it is protected) and define the class.
        Class clazz = null;
        try {
            ClassLoader loader = ClassLoader.getSystemClassLoader();
            Class cls = Class.forName("java.lang.ClassLoader");
            java.lang.reflect.Method method =
                    cls.getDeclaredMethod(
                            "defineClass",
                            new Class[] { String.class, byte[].class, int.class, int.class });

            // Protected method invocation.
            method.setAccessible(true);
            try {
                Object[] args =
                        new Object[] { className, b, new Integer(0), new Integer(b.length)};
                clazz = (Class) method.invoke(loader, args);
            } finally {
                method.setAccessible(false);
            }
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
        return clazz;
    }

    //    @Test
    public void renameClass() throws IOException {
        String classToRename = "org.mitre.emd.rules.Factor";  // This is the class you want to rename
        String classToWrite = "StudentFactor";  // Name of the new class we're writing
        String slashName = classToRename.replace('.', '/');

        ClassReader reader = new ClassReader(classToRename);
        ClassWriter writer = new ClassWriter(0);

        Remapper remapper = new Remapper() {
            @Override
            public String map(String typeName) {
                if (typeName.equals(slashName)) {
                    return "org/mitre/emd/" + classToWrite;
                }
                return super.map(typeName);
            }
        };

        ClassRemapper adapter = new ClassRemapper(writer, remapper);
        reader.accept(adapter, ClassReader.EXPAND_FRAMES);
        writer.visitEnd();

        Transformer transformer = new Transformer();
        byte[] bytes = writer.toByteArray();
        transformer.writeClass(bytes,classToWrite);

    }

//    @Test
    public void testMergeAdapter()throws IOException {
        // This ends up with a corrupted class file
        String classToClone = "org.mitre.emd.Factor";  // This is the class you want to clone and put the method from the other class into.
        String classToRead = "org.mitre.emd.models.students.StudentFoo";  // This is the class we read a method from
        String methodToRead = "method2";  // This is the method we want to read in classToRead
        String classToWrite = "StudentFactor";  // Name of the new class we're writing

        ClassReader cr = new ClassReader(classToClone);
        ClassNode cn = new ClassNode();
        cr.accept(cn, 0);

        ClassWriter cw = new ClassWriter(0);
//        ClassReader cr = new ClassReader(classToClone);

        ClassReader otherCr = new ClassReader(classToRead);
        ClassVisitor studentCv = new ClassVisitor(ASM7, cn) { };
        MergeAdapter ma = new MergeAdapter(studentCv, cn);

        Remapper remapper = new Remapper() {
            @Override
            public String map(String typeName) {
                return super.map(typeName);
            }
        };
//        RemappingClassAdapter classRemapper = new RemappingClassAdapter(studentCv,remapper);

//        otherCr.accept(ma,0);

//        cr.accept(studentCv,0);

        Transformer transformer = new Transformer();
        byte[] bytes = cw.toByteArray();
        transformer.writeClass(bytes,classToWrite);

    }


    //    @Test
    public void testMethodClone() throws IOException {
        String classToClone = "org.mitre.emd.rules.Factor";  // This is the class you want to clone and put the method from the other class into.
        String classToRead = "org.mitre.emd.models.students.StudentFoo";  // This is the class we read a method from
        String methodToRead = "method2";  // This is the method we want to read in classToRead
        String classToWrite = "StudentFactor";  // Name of the new class we're writing
        int expectedChildren = 1;

        ClassWriter cw = new ClassWriter(0);
        ClassReader cr = new ClassReader(classToClone);
        ClassVisitor cv = new ClassVisitor(ASM7, cw) { };

        ClassReader otherCr = new ClassReader(classToRead);
        ClassVisitor studentCv = new ClassVisitor(ASM7, cv) { };
        ClassNode classNode = new ClassNode(ASM7);
        ClassAdapter otherCp = new ClassAdapter(studentCv,classNode, methodToRead);
        otherCr.accept(otherCp,0);

        cr.accept(cv,0);

        Transformer transformer = new Transformer();
        byte[] bytes = cw.toByteArray();
        transformer.writeClass(bytes,classToWrite);

    }

    /**
     * Used in testMethodClone and testInlineMethod
     */
    public class ClassAdapter extends ClassVisitor{
        MethodVisitor newMethod;

        private ClassNode cn;
        private String className;
        private String methodToRead;

        public ClassAdapter(ClassVisitor cv, ClassNode cn, String methodToRead) {
            super(ASM7,cv);
            this.cn = cn;
            this.methodToRead = methodToRead;
        }
        public void visit(int version, int access, String name,
                          String signature,
                          String superName, String[] interfaces) {
            super.visit(version, access,
                    name, signature, superName, interfaces);
            this.className = name;
        }

        /**
         * If a method's name matches methodToRead it's body is copied to the new class otherwise it's ignored.
         * @param access
         * @param name
         * @param desc
         * @param signature
         * @param exceptions
         * @return
         */
        public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions){
            System.out.println(" " + name + desc);
            MethodVisitor mv = cv.visitMethod(access, name, desc, signature, exceptions);

            if(name.equals(methodToRead)){
                System.out.println("found!");

                newMethod = new MethodVisitor(ASM7,mv) {
                    @Override
                    public void visitCode() {
                        super.visitCode();
                    }
                };
                return newMethod;
            }
            return null;
        }

//        public void visitEnd() {
//            Iterator fieldIterator = cn.fields.iterator();
//            while(fieldIterator.hasNext()) {
//                ((FieldNode) fieldIterator.next()).accept(this);
//            }
//            Iterator methodIterator = cn.methods.iterator();
//
//            while(methodIterator.hasNext()) {
//                MethodNode mn = (MethodNode) methodIterator.next();
//                MethodVisitor mv = cv.visitMethod(mn.access, mn.name, mn.desc, mn.signature,
//                        (String[]) mn.exceptions.toArray());
//                if(mn.name.equals("eval")){
//                    continue;
//                }
//                mn.instructions.resetLabels();
//                mn.accept(new RemappingMethodAdapter(mn.access, mn.desc, mv,
//                        new SimpleRemapper(cn.name, className))); }
//            super.visitEnd();
//        }

//        public void visitEnd() {
//                    MethodVisitor mv =  newMethod;
//
//            if (mv != null) {
//
//                mv.visitEnd();
//            }
//            cv.visitEnd();
//            System.out.println("}");
//        }
    }

    //    @Test
    public void testInlineMethod() throws IOException {
        String classToClone = "org.mitre.emd.Factor";  // This is the class you want to clone and put the method from the other class into.
        String classToRead = "org.mitre.emd.models.students.StudentFoo";  // This is the class we read a method from
        String methodToRead = "method2";  // This is the method we want to read in classToRead
        String classToWrite = "StudentFactor";  // Name of the new class we're writing

        ClassWriter cw = new ClassWriter(0);
        ClassReader cr = new ClassReader(classToClone);
        ClassVisitor cv = new ClassVisitor(ASM7, cw) { };

        ClassReader otherCr = new ClassReader(classToRead);
        ClassVisitor studentCv = new ClassVisitor(ASM7, cv) { };
//        ClassAdapter otherCp = new ClassAdapter(studentCv);
        ClassNode classNode = new ClassNode(ASM7);
        ClassAdapter otherCp = new ClassAdapter(studentCv,classNode, methodToRead);
//        MethodCallInliner mci = new MethodCallInliner(ASM7, String desc, MethodVisitor mv, MethodNode mn,
//                classToClone, classToWrite);
        otherCr.accept(otherCp,0);

//        ClassAdapter cp = new ClassAdapter(cv);
        cr.accept(cv,0);

//        cw.

        Transformer transformer = new Transformer();
        byte[] bytes = cw.toByteArray();
        transformer.writeClass(bytes,classToWrite);
    }

    public class FilterAdapter extends ClassVisitor {
        public FilterAdapter(ClassVisitor cv) {
            super(ASM7,cv);
        }
        public MethodVisitor visitMethod(
                int acc, String name, String desc,
                String signature, String[] exceptions) {
            MethodVisitor mv = cv.visitMethod(acc, name, desc, signature, exceptions);
//            if (isFooMethod(name, desc)) {
//                mv = new FooMethodAdapter(mv, acc,
//                        name, desc);
//            }
            return mv;
        }
    }

    public class MethodCallInliner
            extends LocalVariablesSorter {
        private final String oldClass;
        private final String newClass;
        private final MethodNode mn;
        private List blocks = new ArrayList();
        private boolean inlining;

        private MethodCallInliner(int access, String desc, MethodVisitor mv, MethodNode mn,
                                  String oldClass, String newClass) {
            super(access, desc, mv);
            this.oldClass = oldClass;
            this.newClass = newClass;
            this.mn = mn;
        }

        public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean isInterface) {
            if(!canBeInlined(owner, name, desc)) {
                mv.visitMethodInsn(opcode, owner, name, desc,isInterface);
                return;
            }
            Map map = Collections.singletonMap( oldClass, newClass);
            Remapper remapper = new SimpleRemapper(map);
            Label end = new Label();
            inlining = true;
            mn.instructions.resetLabels();
            int passedOpcode = opcode==Opcodes.INVOKESTATIC ? Opcodes.ACC_STATIC : 0;
            mn.accept(new InliningAdapter(this, end, passedOpcode, desc, remapper));
            inlining = false;
            super.visitLabel(end);
        }

        public void visitTryCatchBlock(LabelNode start, LabelNode end, LabelNode handler, String type) {
            if(!inlining) {
                blocks.add(new TryCatchBlockNode(start, end, handler, type));
            } else { super.visitTryCatchBlock(start.getLabel(), end.getLabel(),handler.getLabel(), type);
            }
        }

        public void visitMaxs(int stack, int locals) {
            Iterator it = blocks.iterator(); while(it.hasNext()) {
                TryCatchBlockNode b = (TryCatchBlockNode) it.next(); visitTryCatchBlock(b.start, b.end,
                        b.handler, b.type); }
            super.visitMaxs(stack,locals);
        }

        public boolean canBeInlined(String owner, String name, String desc){
            if(name.equals(mn.name)){
                return true;
            }
            return false;
        }
    }

    public static class InliningAdapter extends MethodRemapper {
        private final LocalVariablesSorter lvs;
        private final Label end;

        public InliningAdapter(LocalVariablesSorter mv,
                               Label end, int acc, String desc,
                               Remapper remapper) {
            super(mv, remapper);
            this.lvs = mv;
            this.end = end;
            int offset = (acc & Opcodes.ACC_STATIC) != 0 ? 0 : 1;
            Type[] args = Type.getArgumentTypes(desc);
            for (int i = args.length - 1; i >= 0; i--) {
                super.visitVarInsn(args[i].getOpcode(Opcodes.ISTORE), i + offset);
            }
            if (offset > 0) {
                super.visitVarInsn(Opcodes.ASTORE, 0);
            }
        }

        public void visitInsn(int opcode) {
            if (opcode == Opcodes.RETURN) {
                super.visitJumpInsn(Opcodes.GOTO, end);
            } else {
                super.visitInsn(opcode);
            }
        }

        public void visitMaxs(int stack, int locals) {
        }

        protected int newLocalMapping(Type type) {
            return lvs.newLocal(type);
        }
    }

//    @Test
    public void testClassPrinter() throws IOException {
        ClassPrinter cp = new ClassPrinter();
        ClassReader cr = new ClassReader("java.lang.Runnable");
        cr.accept(cp, 0);
    }

    public class ClassPrinter extends ClassVisitor {
        public ClassPrinter() {
            super(ASM4);
        }
        public void visit(int version, int access, String name,
                          String signature, String superName, String[] interfaces) {
            System.out.println(signature + " signature");
            System.out.println(name + " extends " + superName + " {");
        }
        public void visitSource(String source, String debug) {
        }
        public void visitOuterClass(String owner, String name, String desc) {
        }
        public AnnotationVisitor visitAnnotation(String desc,
                                                 boolean visible) {
            System.out.println("    annotation desc: " + desc);
            return null;
        }
        public void visitAttribute(Attribute attr) {
            System.out.println("    attribute: " + attr.toString());
        }
        public void visitInnerClass(String name, String outerName,
                                    String innerName, int access) {
        }
        public FieldVisitor visitField(int access, String name, String desc,
                                       String signature, Object value) {
            System.out.println("    " + desc + " " + name);
            return null;
        }
        public MethodVisitor visitMethod(int access, String name,
                                         String desc, String signature, String[] exceptions) {
            System.out.println("    " + name + desc);
            return null;
        }
        public void visitEnd() {
            System.out.println("}");
        }
        }
}
